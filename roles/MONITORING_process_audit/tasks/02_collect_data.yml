---
# This file is executed on every target host to collect and process audit logs.

# 1. Calculate yesterday's date using the 'date' command, which is reliable across Linux distros.
- name: "02.1 | Calculate yesterday's date string"
  ansible.builtin.shell:
    # Use the date command to get the date exactly 24 hours ago (YYYY-MM-DD)
    cmd: "date -d '1 day ago' +%Y-%m-%d"
  register: yesterday_date_result
  when: process_audit_collect_logs | bool
  tags:
    - audit_collect

- name: "02.1b | Define audit log directory and yesterday date"
  ansible.builtin.set_fact:
    audit_log_dir: "/var/tmp"
    yesterday_date: "{{ yesterday_date_result.stdout }}"
  when: process_audit_collect_logs | bool and yesterday_date_result.rc == 0

- name: "02.1c | Define log file paths"
  ansible.builtin.set_fact:
    log_today_path: "{{ audit_log_dir }}/process_audit_{{ inventory_hostname }}_{{ ansible_date_time.date }}.log"
    log_yesterday_path: "{{ audit_log_dir }}/process_audit_{{ inventory_hostname }}_{{ yesterday_date }}.log"
  when: process_audit_collect_logs | bool and yesterday_date is defined


# --- STEP A: COLLECT TODAY'S DATA ---

- name: "02.2 | Collect today's process execution logs"
  ansible.builtin.shell:
    cmd: "ausearch -k {{ audit_rule_key }} --start today | grep exe="
  register: today_logs
  failed_when: today_logs.rc > 1 # Allow rc=1 (no matches)
  when: process_audit_collect_logs | bool

- name: "02.3 | Save today's logs to file for persistence"
  ansible.builtin.copy:
    content: "{{ today_logs.stdout }}"
    dest: "{{ log_today_path }}"
    mode: '0600'
  when: process_audit_collect_logs | bool

# --- STEP B: CHECK FOR YESTERDAY'S DATA ---

- name: "02.4 | STAT: Check if yesterday's log file exists"
  ansible.builtin.stat:
    path: "{{ log_yesterday_path }}"
  register: yesterday_log_status
  when: process_audit_collect_logs | bool and yesterday_date is defined

# --- STEP C: COMPARE (Handles First-Run and Nth-Run) ---

- name: "02.5 | Set comparison source path"
  ansible.builtin.set_fact:
    # If yesterday's log file exists, use it. Otherwise, use /dev/null for first-run comparison.
    comparison_source_path: >
      {% if yesterday_log_status.stat.exists | default(false) %}
        {{ log_yesterday_path }}
      {% else %}
        /dev/null
      {% endif %}
  when: process_audit_collect_logs | bool and yesterday_log_status is defined

- name: "02.6 | Compare today vs. previous logs to find new processes"
  ansible.builtin.shell: "comm -13 <(sort {{ comparison_source_path }}) <(sort {{ log_today_path }}) | grep 'exe='"
  args:
    executable: /bin/bash
  register: new_processes_result
  changed_when: false
  failed_when: false
  when:
    - process_audit_collect_logs | bool
    - today_logs.stdout is defined and today_logs.stdout | length > 0

# --- STEP D: SET FACT AND CLEANUP ---

- name: "02.7 | Set fact for unique new executable paths"
  ansible.builtin.set_fact:
    unique_new_processes: >-
      {% set results = [] %}
      {% if new_processes_result.stdout is defined and new_processes_result.stdout | length > 0 %}
        {% for line in new_processes_result.stdout.splitlines() %}
          {% set m = line | regex_search('exe=([^\s]+)', '\\1') %}
          {% if m is defined and m != '' %}
            {% set _ = results.append(m) %}
          {% endif %}
        {% endfor %}
      {% endif %}
      {{ results | unique | list }}
  when: process_audit_collect_logs | bool



- name: "02.8 | Clean up old log file (Yesterday's file is now obsolete)"
  ansible.builtin.file:
    path: "{{ log_yesterday_path }}"
    state: absent
  # Only attempt cleanup if we successfully determined yesterday's date
  when: process_audit_collect_logs | bool and yesterday_date is defined
  ignore_errors: true