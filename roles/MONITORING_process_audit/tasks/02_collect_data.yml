---
# This file is executed on every target host to collect and process audit logs.

- name: "02.1 | Define log files and calculate yesterday's date"
  ansible.builtin.set_fact:
    audit_log_dir: "/var/tmp"
    # Calculate file names using hostname and date
    log_today_path: "{{ audit_log_dir }}/process_audit_{{ inventory_hostname }}_{{ ansible_date_time.date }}.log"
    
    # Calculate yesterday's date using built-in filters (ISO8601 -> timestamp -> subtract 24h -> datetime -> strftime)
    yesterday_timestamp: "{{ ansible_date_time.iso8601_basic_short | to_datetime('%Y%m%dT%H%M%S', utc=True) | int - 86400 }}"
    yesterday_date: "{{ yesterday_timestamp | timestamp_to_datetime | ansible.builtin.strftime('%Y-%m-%d') }}"
    log_yesterday_path: "{{ audit_log_dir }}/process_audit_{{ inventory_hostname }}_{{ yesterday_date }}.log"
  when: process_audit_collect_logs | bool
  tags:
    - audit_collect

# --- STEP A: COLLECT TODAY'S DATA ---

- name: "02.2 | Collect today's process execution logs"
  ansible.builtin.shell:
    cmd: "ausearch -k {{ audit_rule_key }} --start today | grep exe="
  register: today_logs
  failed_when: today_logs.rc > 1 # Allow rc=1 (no matches)
  when: process_audit_collect_logs | bool

- name: "02.3 | Save today's logs to file for persistence"
  ansible.builtin.copy:
    content: "{{ today_logs.stdout }}"
    dest: "{{ log_today_path }}"
    mode: '0600'
  when: process_audit_collect_logs | bool

# --- STEP B: CHECK FOR YESTERDAY'S DATA ---

- name: "02.4 | STAT: Check if yesterday's log file exists"
  ansible.builtin.stat:
    path: "{{ log_yesterday_path }}"
  register: yesterday_log_status
  when: process_audit_collect_logs | bool

# --- STEP C: COMPARE (Handles First-Run and Nth-Run) ---

- name: "02.5 | Set comparison source path"
  ansible.builtin.set_fact:
    # If yesterday's log file exists (stat.exists is True), use it. Otherwise, use /dev/null for first-run comparison.
    comparison_source_path: >
      {% if yesterday_log_status.stat.exists | default(false) %}
        {{ log_yesterday_path }}
      {% else %}
        /dev/null
      {% endif %}
  when: process_audit_collect_logs | bool

- name: "02.6 | Compare today vs. previous logs to find new processes"
  ansible.builtin.shell:
    cmd: "comm -13 <(sort {{ comparison_source_path }}) <(sort {{ log_today_path }})"
    args:
      executable: /bin/bash # Required for process substitution (<(...))
  register: new_processes_result
  failed_when: new_processes_result.rc != 0
  when:
    - process_audit_collect_logs | bool
    # Only run comparison if today's log has content.
    - today_logs.stdout is defined and today_logs.stdout | length > 0

# --- STEP D: SET FACT AND CLEANUP ---

- name: "02.7 | Set fact for unique new executable paths"
  ansible.builtin.set_fact:
    # If Task 02.6 ran and had output, clean and set the list; otherwise, set an empty list ([]).
    unique_new_processes: |
      {% if new_processes_result is defined and not new_processes_result.skipped and new_processes_result.stdout is defined and new_processes_result.stdout | length > 0 %}
        {{ new_processes_result.stdout.splitlines() | map('regex_replace', '.*exe=([^\\s]+).*', '\\1') | unique | list }}
      {% else %}
        []
      {% endif %}
  when: process_audit_collect_logs | bool

- name: "02.8 | Clean up old log file (Yesterday's file is now obsolete)"
  ansible.builtin.file:
    path: "{{ log_yesterday_path }}"
    state: absent
  # Only attempt cleanup if the previous date was successfully calculated
  when: process_audit_collect_logs | bool and yesterday_date is defined
  ignore_errors: true