---
## tasks file for privileged_user_audit
#
#- name: Collect users with UID 0 (root equivalent)
#  ansible.builtin.shell: "awk -F: '$3 == 0 {print $1}' /etc/passwd"
#  register: root_users_raw
#  changed_when: false
#
#- name: Get all user accounts with their UIDs
#  ansible.builtin.shell: "awk -F: '{print $1 \":\" $3}' /etc/passwd"
#  register: all_users_uid_raw
#  changed_when: false
#
#- name: Build user to UID map
#  ansible.builtin.set_fact:
#    user_uid_map: >- # Changed from '|' to '>-' for explicit block scalar (though | should work too)
#      {% set user_uids = {} %}
#      {% for line in all_users_uid_raw.stdout_lines %}
#        {% if line | trim %}
#          {% set parts = line.split(':') %}
#          {% if parts | length == 2 %}
#            {% set _ = user_uids.update({parts[0] | trim: parts[1] | trim}) %}
#          {% endif %}
#        {% endif %}
#      {% endfor %}
#      {{ user_uids }} # <--- REMOVED | to_json and | string
#
#- name: Collect sudo users by parsing sudoers files
#  ansible.builtin.shell: |
#    # Grep for lines that define user/group permissions, excluding comments and empty lines
#    # Look for patterns like 'user ALL=' or '%group ALL='
#    grep -E '^\s*(%?[[:alnum:]_][[:alnum:]_.:-]*)\s+ALL=' /etc/sudoers /etc/sudoers.d/* 2>/dev/null | \
#    # Extract the user/group name (the first field)
#    awk '{print $1}' | \
#    # Remove duplicates and sort
#    sort -u
#  register: sudoers_users_raw
#  changed_when: false
#  ignore_errors: yes
#
#- name: Set sudo users list (unique and refined)
#  ansible.builtin.set_fact:
#    # Filter out anything that isn't a likely username or group name (starts with % for group)
#    sudoers_defined_users: >-
#      {{ (sudoers_users_raw.stdout_lines | default([])) | select('match', '^%?[a-zA-Z0-9_-]+$') | list | unique }}
#
#- name: Combine root and sudo users, unique and sort for consistent reporting
#  ansible.builtin.set_fact:
#    # Ensure 'root' is always included if it's not detected by sudoers parsing (e.g. if it uses NOPASSWD for everything)
#    privileged_users: "{{ (root_users_raw.stdout_lines + sudoers_defined_users) | unique | sort }}"
#
#- name: Get home directories for privileged users
#  ansible.builtin.shell: "getent passwd {{ item }} | cut -d: -f6"
#  loop: "{{ privileged_users }}"
#  register: home_dirs_raw
#  changed_when: false
#
#- name: Build map of user to home directory
#  ansible.builtin.set_fact:
#    user_homes: >-
#      {{
#        dict(privileged_users | zip(home_dirs_raw.results | map(attribute='stdout') | list))
#      }}
#
#- name: Check .ssh/authorized_keys existence and permissions
#  ansible.builtin.stat:
#    path: "{{ user_homes[item] | default('') }}/.ssh/authorized_keys" # Added default('') to handle cases where home_dir might be N/A
#  loop: "{{ privileged_users }}"
#  register: ssh_auth_keys_stats_raw
#  ignore_errors: yes
#
#- name: Build ssh key info map for users
#  ansible.builtin.set_fact:
#    ssh_key_info: >-
#      {{
#        dict(
#          privileged_users | zip(
#            ssh_auth_keys_stats_raw.results | map(attribute='stat') | list
#          )
#        )
#      }}
#
#- name: Collect sudo -l output for each privileged user
#  ansible.builtin.shell: "sudo -U {{ item }} -l"
#  loop: "{{ privileged_users }}"
#  register: sudo_l_output_raw
#  ignore_errors: yes
#
#- name: Build sudo command map per user
#  ansible.builtin.set_fact:
#    sudo_l_output: >-
#      {{
#        dict(
#          privileged_users | zip(
#            sudo_l_output_raw.results | map(attribute='stdout') | list
#          )
#        )
#      }}
#
#- name: Gather owned files (first 50 for each user, to avoid huge output)
#  ansible.builtin.shell: |
#    find / -user {{ item }} -ls 2>/dev/null | head -n 50 || true
#  loop: "{{ privileged_users }}"
#  register: user_files_raw
#  changed_when: false
#  ignore_errors: yes
#
#- name: Build map of user to their file listings
#  ansible.builtin.set_fact:
#    user_files: >-
#      {{
#        dict(
#          privileged_users | zip(
#            user_files_raw.results | map(attribute='stdout_lines') | list
#          )
#        )
#      }}
#
#- name: Assemble audit report content
#  ansible.builtin.template:
#    src: report.j2
#    dest: /tmp/privileged_user_access_report.txt
#    mode: '0644'
#  vars:
#    report_date: "{{ ansible_date_time.date }} {{ ansible_date_time.time }}"
#    privileged_users_list: "{{ privileged_users }}"
#    user_uid_map: "{{ user_uid_map }}" # This is a JSON string from to_nice_json
#    user_homes: "{{ user_homes }}"
#    ssh_key_info: "{{ ssh_key_info }}"
#    sudo_l_output: "{{ sudo_l_output }}"
#    user_files: "{{ user_files }}"
#
#- name: Display report path
#  ansible.builtin.debug:
#    msg: "Privileged user audit report generated at /tmp/privileged_user_access_report.txt"


- name: Gather all system users
  ansible.builtin.getent:
    database: passwd
  register: all_users_info

- name: Initialize usernames and home directories lists/dicts
  ansible.builtin.set_fact:
    system_users: []
    user_home_dirs: {}

- name: Populate system_users and user_home_dirs with robust checks
  ansible.builtin.set_fact:
    system_users: "{{ system_users + [ user_info.key ] }}"
    user_home_dirs: "{{ user_home_dirs | combine({user_info.key: user_info.value[5]}) }}"
  loop: "{{ all_users_info.ansible_facts.getent_passwd | dict2items }}"
  loop_control:
    loop_var: user_info
  when:
    # Ensure 'value' exists and is a list/iterable
    - user_info.value is defined
    - user_info.value is iterable
    # Ensure the list has enough elements for index 5 (6th element)
    - user_info.value | length > 5
    # Ensure the home directory path itself is defined and starts with '/'
    - user_info.value[5] is defined
    - user_info.value[5] is string # Ensure it's a string before calling string method
    - user_info.value[5].startswith('/') # CORRECTED LINE HERE (from starts_with to startswith)

- name: Initialize privileged access report data structure
  ansible.builtin.set_fact:
    privileged_report_data:
      timestamp: "{{ ansible_date_time.iso8601 }}"
      sudo_privileges: []
      authorized_keys: []
      sensitive_directory_permissions: []
      sudoers_files_content: {}

- name: Find sudoers files
  ansible.builtin.find:
    paths:
      - /etc/sudoers
      - /etc/sudoers.d
    file_type: file
    recurse: yes
  register: sudoers_files_found

- name: Read content of sudoers files
  ansible.builtin.slurp:
    src: "{{ item.path }}"
  loop: "{{ sudoers_files_found.files }}"
  loop_control:
    label: "{{ item.path }}"
  register: sudoers_files_content_raw

- name: Add sudoers files content to report
  ansible.builtin.set_fact:
    privileged_report_data: "{{ privileged_report_data | combine({'sudoers_files_content': sudoers_files_content_raw.results | items2dict(key_name='item.path', value_name='content') | dict_walk('from_b64') }) }}"
  when: sudoers_files_content_raw.results is defined

- name: Check sudo privileges for each user
  ansible.builtin.command: "sudo -l -U {{ item }}"
  become: yes # Assumes the Ansible connection user has sudo access to run 'sudo -l' for other users
  register: user_sudo_output
  loop: "{{ system_users }}"
  loop_control:
    label: "{{ item }}"
  ignore_errors: true # Some users might not have sudo, which is expected

- name: Process sudo output
  ansible.builtin.set_fact:
    privileged_report_data:
      sudo_privileges: "{{ privileged_report_data.sudo_privileges + [ { 'user': item.item, 'output': item.stdout | default('N/A'), 'rc': item.rc } ] }}"
  loop: "{{ user_sudo_output.results }}"
  loop_control:
    label: "{{ item.item }}"
  when: item.skipped is not defined # Ensure we only process results that actually ran

- name: Check authorized_keys for each user and collect data
  ansible.builtin.include_tasks: check_user_privileges.yml
  loop: "{{ system_users }}"
  loop_control:
    loop_var: current_user # Make the current user item accessible as 'current_user' in the included task
    label: "Processing authorized_keys for {{ current_user }}"
  when: user_home_dirs[current_user] is defined and user_home_dirs[current_user] is not none

- name: Get permissions for sensitive directories
  ansible.builtin.stat:
    path: "{{ item }}"
  register: dir_stat_results
  loop: "{{ sensitive_directories }}"
  loop_control:
    label: "{{ item }}"
  ignore_errors: true # Some directories might not exist or be accessible

- name: Process sensitive directory permissions
  ansible.builtin.set_fact:
    privileged_report_data:
      sensitive_directory_permissions: "{{ privileged_report_data.sensitive_directory_permissions + [ { 'path': item.item, 'owner': item.stat.pw_name | default('N/A'), 'group': item.stat.gr_name | default('N/A'), 'mode': item.stat.mode | default('N/A'), 'islnk': item.stat.islnk | default(false) } ] }}"
  loop: "{{ dir_stat_results.results }}"
  loop_control:
    label: "{{ item.item }}"
  when: item.stat is defined and not item.failed

- name: Generate privileged access audit report
  ansible.builtin.template:
    src: privileged_access_report.j2
    dest: "/tmp/privileged_access_audit_report_{{ ansible_hostname }}_{{ ansible_date_time.iso8601 }}.txt"
    mode: '0600'
  delegate_to: localhost # Generate report on the Ansible control node
  run_once: true

- name: Display path to generated report
  ansible.builtin.debug:
    msg: "Privileged access audit report generated at /tmp/privileged_access_audit_report_{{ ansible_hostname }}_{{ ansible_date_time.iso8601 }}.txt on the Ansible control node."
  run_once: true