---
- name: Gather all system users
  ansible.builtin.getent:
    database: passwd
  register: all_users_info

- name: Initialize usernames and home directories lists/dicts
  ansible.builtin.set_fact:
    system_users: []
    user_home_dirs: {}

- name: Populate system_users and user_home_dirs with robust checks
  ansible.builtin.set_fact:
    system_users: "{{ system_users + [ user_info.key ] }}"
    user_home_dirs: "{{ user_home_dirs | combine({user_info.key: user_info.value[5]}) }}" # Correct index [5] for HOME_DIRECTORY
  loop: "{{ all_users_info.ansible_facts.getent_passwd | dict2items }}"
  loop_control:
    loop_var: user_info
  when:
    # 1. Basic data structure validation (ensure enough fields and proper types)
    - user_info.value is defined and user_info.value is iterable
    - user_info.value | length > 5 # Ensure index 5 (home) and 6 (shell) exist
    - user_info.value[5] is defined and user_info.value[5] is string
    - user_info.value[6] is defined and user_info.value[6] is string

    # 2. Filter criteria for *including* users (either root or a "normal" user)
    - (user_info.key == 'root') or ( # Always include 'root'
        # For non-root users, check for typical characteristics of a login user
        user_info.value[1] | int >= 1000 and # Standard users usually have UIDs >= 1000
        user_info.value[5].startswith('/') and # Home directory starts with /
        # Exclude common non-login shells (add any other variations you see on your system)
        not (user_info.value[6] in ['/sbin/nologin', '/bin/false', '/usr/sbin/nologin', '/sbinologin', '/usr/bin/nologin']) and
        # Exclude common home directories that are not true user homes
        not (user_info.value[5] in ['/bin', '/sbin', '/proc', '/dev/null', '/run', '/var/empty/sshd', '/var/lib/colord', '/var/cache/clevis', '/var/run/avahi-daemon', '/var/lib/chrony', '/var/lib/setroubleshoot', '/var/lib/dnsmasq', '/var/lib/gdm', '/run/gnome-initial-setup/', '/run/pesign', '/var/lib/rpcbind', '/var/libfs', '/var/lib/dnsmasq', '/var/lib/geoclue'])
      )

- name: Initialize privileged access report data structure
  ansible.builtin.set_fact:
    privileged_report_data:
      timestamp: "{{ ansible_date_time.iso8601 }}"
      sudo_privileges: []
      authorized_keys: []
      sensitive_directory_permissions: []
      sudoers_files_content: []

- name: Find sudoers files
  ansible.builtin.find:
    paths:
      - /etc/sudoers
      - /etc/sudoers.d
    file_type: file
    recurse: yes
  register: sudoers_files_found

- name: Read content of sudoers files
  ansible.builtin.slurp:
    src: "{{ item.path }}"
  loop: "{{ sudoers_files_found.files }}"
  loop_control:
    label: "{{ item.path }}"
  register: sudoers_files_content_raw

- name: Add sudoers files content to report
  ansible.builtin.set_fact:
    privileged_report_data: "{{ privileged_report_data | combine({
      'sudoers_files_content': privileged_report_data.sudoers_files_content + [ { 'path': item.item.path, 'content': item.content | b64decode } ]
    }) }}"
  loop: "{{ sudoers_files_content_raw.results }}"
  loop_control:
    label: "{{ item.item.path }}"
  when:
    - item.content is defined
    - item.item.path is defined

- name: Check sudo privileges for each user
  ansible.builtin.command: "sudo -l -U {{ item }}"
  become: yes
  register: user_sudo_output
  loop: "{{ system_users }}"
  loop_control:
    label: "{{ item }}"
  ignore_errors: true

- name: Process sudo output
  ansible.builtin.set_fact:
    privileged_report_data: "{{ privileged_report_data | combine({
      'sudo_privileges': privileged_report_data.sudo_privileges + [ { 'user': item.item, 'output': item.stdout | default('N/A'), 'rc': item.rc } ]
    }) }}"
  loop: "{{ user_sudo_output.results }}"
  loop_control:
    label: "{{ item.item }}"
  when: item.skipped is not defined

- name: Check authorized_keys for each user and collect data
  ansible.builtin.include_tasks: check_user_privileges.yml
  loop: "{{ system_users }}"
  loop_control:
    loop_var: current_user
    label: "Processing authorized_keys for {{ current_user }}"
  vars:
    # Pass the correctly filtered home directory to the included task
    user_specific_home_dir: "{{ user_home_dirs[current_user] }}"
  # Removed: the 'when' condition from here, as filtering is now done in 'Populate' task.
  # This makes the loop include only relevant users for authorized_keys checks.

- name: Get permissions for sensitive directories
  ansible.builtin.stat:
    path: "{{ item }}"
  register: dir_stat_results
  loop: "{{ sensitive_directories }}"
  loop_control:
    label: "{{ item }}"
  ignore_errors: true

- name: Process sensitive directory permissions
  ansible.builtin.set_fact:
    privileged_report_data: "{{ privileged_report_data | combine({
      'sensitive_directory_permissions': privileged_report_data.sensitive_directory_permissions + [ { 'path': item.item, 'owner': item.stat.pw_name | default('N/A'), 'group': item.stat.gr_name | default('N/A'), 'mode': item.stat.mode | default('N/A'), 'islnk': item.stat.islnk | default(false) } ]
    }) }}"
  loop: "{{ dir_stat_results.results }}"
  loop_control:
    label: "{{ item.item }}"
  when: item.stat is defined and not item.failed

- name: Generate privileged access audit report on target node
  ansible.builtin.template:
    src: privileged_access_report.j2
    dest: "/tmp/privileged_access_audit_report_{{ ansible_hostname }}_{{ ansible_date_time.iso8601 }}.txt"
    mode: '0600'

- name: Display path to generated report on target node
  ansible.builtin.debug:
    msg: "Privileged access audit report generated at /tmp/privileged_access_audit_report_{{ ansible_hostname }}_{{ ansible_date_time.iso8601 }}.txt on the target node."